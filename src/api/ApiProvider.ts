//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { ApiClientBase } from "./ApiClientBase";import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client extends ApiClientBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8080";

    }

    /**
     * Busca sensor por ID
     * @return Sensor encontrado
     */
    getSensorById(id: number , cancelToken?: CancelToken | undefined): Promise<Sensor> {
        let url_ = this.baseUrl + "/sensor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSensorById(_response);
        });
    }

    protected processGetSensorById(response: AxiosResponse): Promise<Sensor> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Sensor.fromJS(resultData200);
            return Promise.resolve<Sensor>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Sensor n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Sensor>(null as any);
    }

    /**
     * Atualiza um sensor
     * @return Sensor atualizado com sucesso
     */
    updateSensor(id: number, body: SensorDTO , cancelToken?: CancelToken | undefined): Promise<Sensor> {
        let url_ = this.baseUrl + "/sensor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSensor(_response);
        });
    }

    protected processUpdateSensor(response: AxiosResponse): Promise<Sensor> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Erro de solicita\u00e7\u00e3o", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Sensor.fromJS(resultData200);
            return Promise.resolve<Sensor>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Sensor n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Sensor>(null as any);
    }

    /**
     * Deleta um sensor
     * @return Sensor deletado com sucesso
     */
    deletesensor(id: number , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/sensor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeletesensor(_response);
        });
    }

    protected processDeletesensor(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Erro interno ao deletar o sensor", status, _responseText, _headers, result500);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Sensor n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Busca uma pessoa por ID
     * @return Pessoa encontrada
     */
    getPessoaById(id: number , cancelToken?: CancelToken | undefined): Promise<Pessoa> {
        let url_ = this.baseUrl + "/pessoa/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPessoaById(_response);
        });
    }

    protected processGetPessoaById(response: AxiosResponse): Promise<Pessoa> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Pessoa.fromJS(resultData200);
            return Promise.resolve<Pessoa>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Pessoa n\u00e3o encontrada", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pessoa>(null as any);
    }

    /**
     * Atualiza uma pessoa
     * @return Pessoa atualizada com sucesso
     */
    updatePessoa(id: number, body: PessoaDTO , cancelToken?: CancelToken | undefined): Promise<Pessoa> {
        let url_ = this.baseUrl + "/pessoa/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePessoa(_response);
        });
    }

    protected processUpdatePessoa(response: AxiosResponse): Promise<Pessoa> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Erro ao atualizar pessoa", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Pessoa.fromJS(resultData200);
            return Promise.resolve<Pessoa>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Pessoa n\u00e3o encontrada", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pessoa>(null as any);
    }

    /**
     * Busca uma medição por ID
     * @return Medição encontrada
     */
    getMedicaoById(id: number , cancelToken?: CancelToken | undefined): Promise<Medicao> {
        let url_ = this.baseUrl + "/medicao/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMedicaoById(_response);
        });
    }

    protected processGetMedicaoById(response: AxiosResponse): Promise<Medicao> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Medi\u00e7\u00e3o n\u00e3o encontrada", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Medicao.fromJS(resultData200);
            return Promise.resolve<Medicao>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Medicao>(null as any);
    }

    /**
     * Atualiza uma medição
     * @return Medição atualizada com sucesso
     */
    updateMedicao(id: number, body: MedicaoDTO , cancelToken?: CancelToken | undefined): Promise<Medicao> {
        let url_ = this.baseUrl + "/medicao/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMedicao(_response);
        });
    }

    protected processUpdateMedicao(response: AxiosResponse): Promise<Medicao> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Medicao.fromJS(resultData200);
            return Promise.resolve<Medicao>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Medi\u00e7\u00e3o n\u00e3o encontrada", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Erro na requisi\u00e7\u00e3o", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Medicao>(null as any);
    }

    /**
     * Deleta um medicao
     * @return Medição deletado com sucesso
     */
    deleteMedicao(id: number , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/medicao/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMedicao(_response);
        });
    }

    protected processDeleteMedicao(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Medi\u00e7\u00e3o n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Erro interno ao deletar o medicao", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Busca um gateway por ID
     * @return Gateway encontrado
     */
    getGatewayById(id: number , cancelToken?: CancelToken | undefined): Promise<Gateway> {
        let url_ = this.baseUrl + "/gateway/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGatewayById(_response);
        });
    }

    protected processGetGatewayById(response: AxiosResponse): Promise<Gateway> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Gateway.fromJS(resultData200);
            return Promise.resolve<Gateway>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Gateway n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Gateway>(null as any);
    }

    /**
     * Atualiza um gateway
     * @return Gateway atualizado com sucesso
     */
    updateGateway(id: number, body: GatewayDto , cancelToken?: CancelToken | undefined): Promise<Gateway> {
        let url_ = this.baseUrl + "/gateway/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateGateway(_response);
        });
    }

    protected processUpdateGateway(response: AxiosResponse): Promise<Gateway> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Erro na requisi\u00e7\u00e3o devido a dados inv\u00e1lidos", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Gateway.fromJS(resultData200);
            return Promise.resolve<Gateway>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Gateway n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Gateway>(null as any);
    }

    /**
     * Deleta um gateway
     * @return Gateway deletado com sucesso
     */
    deleteGateway(id: number , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/gateway/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteGateway(_response);
        });
    }

    protected processDeleteGateway(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Gateway n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Erro interno ao deletar o gateway", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Busca um dispositivo por ID
     * @return Dispositivo encontrado
     */
    getDispositivo(id: number , cancelToken?: CancelToken | undefined): Promise<Dispositivo> {
        let url_ = this.baseUrl + "/dispositivos/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDispositivo(_response);
        });
    }

    protected processGetDispositivo(response: AxiosResponse): Promise<Dispositivo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Dispositivo.fromJS(resultData200);
            return Promise.resolve<Dispositivo>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Dispositivo n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Dispositivo>(null as any);
    }

    /**
     * Atualiza um dispositivo
     * @return Dispositivo atualizado com sucesso
     */
    updateDispositivo(id: number, body: DispositivoDTO , cancelToken?: CancelToken | undefined): Promise<Dispositivo> {
        let url_ = this.baseUrl + "/dispositivos/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDispositivo(_response);
        });
    }

    protected processUpdateDispositivo(response: AxiosResponse): Promise<Dispositivo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Dispositivo.fromJS(resultData200);
            return Promise.resolve<Dispositivo>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Dispositivo n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Erro na requisi\u00e7\u00e3o", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Dispositivo>(null as any);
    }

    /**
     * Deleta um Dispositvo
     * @return Disposiitvo deletado com sucesso
     */
    deletedisposiitvo(id: number , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/dispositivos/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeletedisposiitvo(_response);
        });
    }

    protected processDeletedisposiitvo(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Disposiitvo n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Erro interno ao deletar o Disposiitvo", status, _responseText, _headers, result500);

        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Obtém um atuador por ID
     * @return Atuador encontrado
     */
    getAtuadorById(id: number , cancelToken?: CancelToken | undefined): Promise<Atuador> {
        let url_ = this.baseUrl + "/atuadores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAtuadorById(_response);
        });
    }

    protected processGetAtuadorById(response: AxiosResponse): Promise<Atuador> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Atuador n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Atuador.fromJS(resultData200);
            return Promise.resolve<Atuador>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Atuador>(null as any);
    }

    /**
     * Atualiza um atuador existente
     * @return Atuador atualizado com sucesso
     */
    updateAtuador(id: number, body: AtuadorDTO , cancelToken?: CancelToken | undefined): Promise<Atuador> {
        let url_ = this.baseUrl + "/atuadores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAtuador(_response);
        });
    }

    protected processUpdateAtuador(response: AxiosResponse): Promise<Atuador> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Atuador n\u00e3o encontrado", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Atuador.fromJS(resultData200);
            return Promise.resolve<Atuador>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Erro ao atualizar dados", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Atuador>(null as any);
    }

    /**
     * Lista todos os sensores
     * @return OK
     */
    getAllSensors(  cancelToken?: CancelToken | undefined): Promise<Sensor[]> {
        let url_ = this.baseUrl + "/sensor";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSensors(_response);
        });
    }

    protected processGetAllSensors(response: AxiosResponse): Promise<Sensor[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sensor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Sensor[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Sensor[]>(null as any);
    }

    /**
     * Cria um novo sensor
     * @return Sensor criado com sucesso
     */
    createSensor(body: any , cancelToken?: CancelToken | undefined): Promise<Sensor> {
        let url_ = this.baseUrl + "/sensor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSensor(_response);
        });
    }

    protected processCreateSensor(response: AxiosResponse): Promise<Sensor> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = Sensor.fromJS(resultData201);
            return Promise.resolve<Sensor>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Dados inv\u00e1lidos fornecidos", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Sensor>(null as any);
    }

    /**
     * Lista todas as pessoas
     * @return OK
     */
    getAllPessoas(  cancelToken?: CancelToken | undefined): Promise<Pessoa[]> {
        let url_ = this.baseUrl + "/pessoa";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPessoas(_response);
        });
    }

    protected processGetAllPessoas(response: AxiosResponse): Promise<Pessoa[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pessoa.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Pessoa[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pessoa[]>(null as any);
    }

    /**
     * Cria uma nova pessoa
     * @return Pessoa criada com sucesso
     */
    createPessoa(body: PessoaDTO , cancelToken?: CancelToken | undefined): Promise<Pessoa> {
        let url_ = this.baseUrl + "/pessoa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePessoa(_response);
        });
    }

    protected processCreatePessoa(response: AxiosResponse): Promise<Pessoa> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Erro ao criar pessoa", status, _responseText, _headers, result400);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = Pessoa.fromJS(resultData201);
            return Promise.resolve<Pessoa>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pessoa>(null as any);
    }

    /**
     * Lista todas as medições
     * @return OK
     */
    getAllMedicoes(  cancelToken?: CancelToken | undefined): Promise<Medicao[]> {
        let url_ = this.baseUrl + "/medicao";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllMedicoes(_response);
        });
    }

    protected processGetAllMedicoes(response: AxiosResponse): Promise<Medicao[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Medicao.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Medicao[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Medicao[]>(null as any);
    }

    /**
     * Cria uma nova medição
     * @return Medição criada com sucesso
     */
    createMedicao(body: MedicaoDTO , cancelToken?: CancelToken | undefined): Promise<Medicao> {
        let url_ = this.baseUrl + "/medicao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMedicao(_response);
        });
    }

    protected processCreateMedicao(response: AxiosResponse): Promise<Medicao> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Erro nos dados fornecidos", status, _responseText, _headers, result400);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = Medicao.fromJS(resultData201);
            return Promise.resolve<Medicao>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Medicao>(null as any);
    }

    /**
     * Lista todos os gateways
     * @return OK
     */
    getAllGateways(  cancelToken?: CancelToken | undefined): Promise<Gateway[]> {
        let url_ = this.baseUrl + "/gateway";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllGateways(_response);
        });
    }

    protected processGetAllGateways(response: AxiosResponse): Promise<Gateway[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Gateway.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Gateway[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Gateway[]>(null as any);
    }

    /**
     * Cria um novo gateway
     * @return Gateway criado com sucesso
     */
    createGateway(body: GatewayDto , cancelToken?: CancelToken | undefined): Promise<Gateway> {
        let url_ = this.baseUrl + "/gateway";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateGateway(_response);
        });
    }

    protected processCreateGateway(response: AxiosResponse): Promise<Gateway> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = Gateway.fromJS(resultData201);
            return Promise.resolve<Gateway>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Erro devido a dados inv\u00e1lidos", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Gateway>(null as any);
    }

    /**
     * Lista todos os dispositivos
     * @return OK
     */
    getAllDispositivos(  cancelToken?: CancelToken | undefined): Promise<Dispositivo[]> {
        let url_ = this.baseUrl + "/dispositivos";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllDispositivos(_response);
        });
    }

    protected processGetAllDispositivos(response: AxiosResponse): Promise<Dispositivo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Dispositivo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Dispositivo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Dispositivo[]>(null as any);
    }

    /**
     * Cria um novo dispositivo
     * @return Dispositivo criado com sucesso
     */
    createDispositivo(body: DispositivoDTO , cancelToken?: CancelToken | undefined): Promise<Dispositivo> {
        let url_ = this.baseUrl + "/dispositivos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDispositivo(_response);
        });
    }

    protected processCreateDispositivo(response: AxiosResponse): Promise<Dispositivo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = Dispositivo.fromJS(resultData201);
            return Promise.resolve<Dispositivo>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Dados inv\u00e1lidos fornecidos", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Dispositivo>(null as any);
    }

    /**
     * Cadastro de usuário
     * @return Usuário cadastrado com sucesso
     */
    register(body: PessoaRegisterDTO , cancelToken?: CancelToken | undefined): Promise<Pessoa> {
        let url_ = this.baseUrl + "/auth/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<Pessoa> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Pessoa.fromJS(resultData200);
            return Promise.resolve<Pessoa>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Pessoa.fromJS(resultData400);
            return throwException("Dados inv\u00e1lidos fornecidos", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pessoa>(null as any);
    }

    /**
     * Lista todos os atuadores
     * @return OK
     */
    getAllAtuadores(  cancelToken?: CancelToken | undefined): Promise<Atuador[]> {
        let url_ = this.baseUrl + "/atuadores";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllAtuadores(_response);
        });
    }

    protected processGetAllAtuadores(response: AxiosResponse): Promise<Atuador[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Atuador.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Atuador[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Atuador[]>(null as any);
    }

    /**
     * Cria um novo atuador
     * @return Atuador criado com sucesso
     */
    createAtuador(body: AtuadorDTO , cancelToken?: CancelToken | undefined): Promise<Atuador> {
        let url_ = this.baseUrl + "/atuadores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAtuador(_response);
        });
    }

    protected processCreateAtuador(response: AxiosResponse): Promise<Atuador> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = Atuador.fromJS(resultData201);
            return Promise.resolve<Atuador>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Dados inv\u00e1lidos fornecidos", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Atuador>(null as any);
    }
}

export class SensorDTO {
    nome!: string;
    tipo!: string;
    medicoesIds?: number[];
    dispositivoId!: number;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nome = _data["nome"];
            this.tipo = _data["tipo"];
            if (Array.isArray(_data["medicoesIds"])) {
                this.medicoesIds = [] as any;
                for (let item of _data["medicoesIds"])
                    this.medicoesIds!.push(item);
            }
            this.dispositivoId = _data["dispositivoId"];
        }
    }

    static fromJS(data: any): SensorDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SensorDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nome"] = this.nome;
        data["tipo"] = this.tipo;
        if (Array.isArray(this.medicoesIds)) {
            data["medicoesIds"] = [];
            for (let item of this.medicoesIds)
                data["medicoesIds"].push(item);
        }
        data["dispositivoId"] = this.dispositivoId;
        return data;
    }
}

export class Atuador {
    id?: number;
    nome?: string;
    dispositivo?: Dispositivo;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.nome = _data["nome"];
            this.dispositivo = _data["dispositivo"] ? Dispositivo.fromJS(_data["dispositivo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Atuador {
        data = typeof data === 'object' ? data : {};
        let result = new Atuador();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["nome"] = this.nome;
        data["dispositivo"] = this.dispositivo ? this.dispositivo.toJSON() : <any>undefined;
        return data;
    }
}

export class Dispositivo {
    id?: number;
    nome?: string;
    descricao?: string;
    gateway?: Gateway;
    sensores?: Sensor[];
    atuadores?: Atuador[];
    latitude?: number;
    longitude?: number;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.nome = _data["nome"];
            this.descricao = _data["descricao"];
            this.gateway = _data["gateway"] ? Gateway.fromJS(_data["gateway"]) : <any>undefined;
            if (Array.isArray(_data["sensores"])) {
                this.sensores = [] as any;
                for (let item of _data["sensores"])
                    this.sensores!.push(Sensor.fromJS(item));
            }
            if (Array.isArray(_data["atuadores"])) {
                this.atuadores = [] as any;
                for (let item of _data["atuadores"])
                    this.atuadores!.push(Atuador.fromJS(item));
            }
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): Dispositivo {
        data = typeof data === 'object' ? data : {};
        let result = new Dispositivo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["nome"] = this.nome;
        data["descricao"] = this.descricao;
        data["gateway"] = this.gateway ? this.gateway.toJSON() : <any>undefined;
        if (Array.isArray(this.sensores)) {
            data["sensores"] = [];
            for (let item of this.sensores)
                data["sensores"].push(item.toJSON());
        }
        if (Array.isArray(this.atuadores)) {
            data["atuadores"] = [];
            for (let item of this.atuadores)
                data["atuadores"].push(item.toJSON());
        }
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export class Gateway {
    id?: number;
    nome?: string;
    descricao?: string;
    endereco?: string;
    dispositivos?: Dispositivo[];
    pessoa?: Pessoa;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.nome = _data["nome"];
            this.descricao = _data["descricao"];
            this.endereco = _data["endereco"];
            if (Array.isArray(_data["dispositivos"])) {
                this.dispositivos = [] as any;
                for (let item of _data["dispositivos"])
                    this.dispositivos!.push(Dispositivo.fromJS(item));
            }
            this.pessoa = _data["pessoa"] ? Pessoa.fromJS(_data["pessoa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Gateway {
        data = typeof data === 'object' ? data : {};
        let result = new Gateway();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["nome"] = this.nome;
        data["descricao"] = this.descricao;
        data["endereco"] = this.endereco;
        if (Array.isArray(this.dispositivos)) {
            data["dispositivos"] = [];
            for (let item of this.dispositivos)
                data["dispositivos"].push(item.toJSON());
        }
        data["pessoa"] = this.pessoa ? this.pessoa.toJSON() : <any>undefined;
        return data;
    }
}

export class Medicao {
    id?: number;
    valor?: number;
    data?: Date;
    sensor?: Sensor;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.valor = _data["valor"];
            this.data = _data["data"] ? new Date(_data["data"].toString()) : <any>undefined;
            this.sensor = _data["sensor"] ? Sensor.fromJS(_data["sensor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Medicao {
        data = typeof data === 'object' ? data : {};
        let result = new Medicao();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["valor"] = this.valor;
        data["data"] = this.data ? this.data.toISOString() : <any>undefined;
        data["sensor"] = this.sensor ? this.sensor.toJSON() : <any>undefined;
        return data;
    }
}

export class Pessoa {
    id?: number;
    nome?: string;
    gateways?: Gateway[];
    email?: string;
    password?: string;
    createdAt?: Date;
    updatedAt?: Date;
    username?: string;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.nome = _data["nome"];
            if (Array.isArray(_data["gateways"])) {
                this.gateways = [] as any;
                for (let item of _data["gateways"])
                    this.gateways!.push(Gateway.fromJS(item));
            }
            this.email = _data["email"];
            this.password = _data["password"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): Pessoa {
        data = typeof data === 'object' ? data : {};
        let result = new Pessoa();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["nome"] = this.nome;
        if (Array.isArray(this.gateways)) {
            data["gateways"] = [];
            for (let item of this.gateways)
                data["gateways"].push(item.toJSON());
        }
        data["email"] = this.email;
        data["password"] = this.password;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["username"] = this.username;
        return data;
    }
}

export class Sensor {
    id?: number;
    nome?: string;
    tipo?: string;
    medicoes?: Medicao[];
    dispositivo?: Dispositivo;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.nome = _data["nome"];
            this.tipo = _data["tipo"];
            if (Array.isArray(_data["medicoes"])) {
                this.medicoes = [] as any;
                for (let item of _data["medicoes"])
                    this.medicoes!.push(Medicao.fromJS(item));
            }
            this.dispositivo = _data["dispositivo"] ? Dispositivo.fromJS(_data["dispositivo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Sensor {
        data = typeof data === 'object' ? data : {};
        let result = new Sensor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["nome"] = this.nome;
        data["tipo"] = this.tipo;
        if (Array.isArray(this.medicoes)) {
            data["medicoes"] = [];
            for (let item of this.medicoes)
                data["medicoes"].push(item.toJSON());
        }
        data["dispositivo"] = this.dispositivo ? this.dispositivo.toJSON() : <any>undefined;
        return data;
    }
}

export class PessoaDTO {
    nome!: string;
    email!: string;
    password!: string;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nome = _data["nome"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): PessoaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PessoaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nome"] = this.nome;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export class MedicaoDTO {
    valor!: number;
    data!: Date;
    sensorId!: number;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.valor = _data["valor"];
            this.data = _data["data"] ? new Date(_data["data"].toString()) : <any>undefined;
            this.sensorId = _data["sensorId"];
        }
    }

    static fromJS(data: any): MedicaoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MedicaoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["valor"] = this.valor;
        data["data"] = this.data ? this.data.toISOString() : <any>undefined;
        data["sensorId"] = this.sensorId;
        return data;
    }
}

export class GatewayDto {
    nome!: string;
    descricao!: string;
    endereco!: string;
    dispositivosIds!: number[];
    pessoaId!: number;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nome = _data["nome"];
            this.descricao = _data["descricao"];
            this.endereco = _data["endereco"];
            if (Array.isArray(_data["dispositivosIds"])) {
                this.dispositivosIds = [] as any;
                for (let item of _data["dispositivosIds"])
                    this.dispositivosIds!.push(item);
            }
            this.pessoaId = _data["pessoaId"];
        }
    }

    static fromJS(data: any): GatewayDto {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nome"] = this.nome;
        data["descricao"] = this.descricao;
        data["endereco"] = this.endereco;
        if (Array.isArray(this.dispositivosIds)) {
            data["dispositivosIds"] = [];
            for (let item of this.dispositivosIds)
                data["dispositivosIds"].push(item);
        }
        data["pessoaId"] = this.pessoaId;
        return data;
    }
}

export class DispositivoDTO {
    nome!: string;
    descricao!: string;
    latitude?: number;
    longitude?: number;
    gatewayId!: number;
    sensoresIds?: number[];
    atuadoresIds?: number[];

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nome = _data["nome"];
            this.descricao = _data["descricao"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.gatewayId = _data["gatewayId"];
            if (Array.isArray(_data["sensoresIds"])) {
                this.sensoresIds = [] as any;
                for (let item of _data["sensoresIds"])
                    this.sensoresIds!.push(item);
            }
            if (Array.isArray(_data["atuadoresIds"])) {
                this.atuadoresIds = [] as any;
                for (let item of _data["atuadoresIds"])
                    this.atuadoresIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DispositivoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DispositivoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nome"] = this.nome;
        data["descricao"] = this.descricao;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["gatewayId"] = this.gatewayId;
        if (Array.isArray(this.sensoresIds)) {
            data["sensoresIds"] = [];
            for (let item of this.sensoresIds)
                data["sensoresIds"].push(item);
        }
        if (Array.isArray(this.atuadoresIds)) {
            data["atuadoresIds"] = [];
            for (let item of this.atuadoresIds)
                data["atuadoresIds"].push(item);
        }
        return data;
    }
}

export class AtuadorDTO {
    nome!: string;
    dispositivoId!: number;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nome = _data["nome"];
            this.dispositivoId = _data["dispositivoId"];
        }
    }

    static fromJS(data: any): AtuadorDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AtuadorDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nome"] = this.nome;
        data["dispositivoId"] = this.dispositivoId;
        return data;
    }
}

export class PessoaRegisterDTO {
    nome!: string;
    email!: string;
    password!: string;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nome = _data["nome"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): PessoaRegisterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PessoaRegisterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nome"] = this.nome;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}